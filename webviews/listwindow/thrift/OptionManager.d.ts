//
// Autogenerated by Thrift Compiler (0.14.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//

import Int64 = require('node-int64');

import { optionmanager } from "./optionmanager_types";


/**
 * Interface of the option manager service towards Thrift
 * clients. Those might not reside in the same process as the service handler itself,
 * therefore all types manipulated by this interface need to be serializable.
 * <p>
 * One typical use case is an Eclipse frontend reading options in an EW project
 * file and/or manipulating its build configurations.
 * 
 */
export declare class Client {
  input: Thrift.TJSONProtocol;
  output: Thrift.TJSONProtocol;
  seqid: number;

  constructor(input: Thrift.TJSONProtocol, output?: Thrift.TJSONProtocol);

  /**
   * Get the currently registered definition of an option.
   * 
   * @throws OptionError if id is not known to the option manager
   */
  getOptionDefinition(id: string): Q.Promise<OptionDefinition>;

  /**
   * Get the currently registered definition of an option.
   * 
   * @throws OptionError if id is not known to the option manager
   */
  getOptionDefinition(id: string, callback?: (data: OptionDefinition)=>void): void;

  /**
   * Register a new option configuration
   * 
   * @param config
   */
  addConfiguration(config: OptionConfiguration): Q.Promise<void>;

  /**
   * Register a new option configuration
   * 
   * @param config
   */
  addConfiguration(config: OptionConfiguration, callback?: (data: void)=>void): void;

  /**
   * Define how a configuration and its options are presented to the user
   * 
   * @param configPresentation
   */
  addConfigurationPresentation(configPresentation: ConfigurationPresentation): Q.Promise<void>;

  /**
   * Define how a configuration and its options are presented to the user
   * 
   * @param configPresentation
   */
  addConfigurationPresentation(configPresentation: ConfigurationPresentation, callback?: (data: void)=>void): void;

  /**
   * Get the presentation information for the given configuration ID.
   * The presentations can be inherited from parent configurations, and all those which are found
   * are returned - possibly none.
   * 
   * @return a (possiblt empty) list of ConfigurationPresentation.
   * 
   */
  getConfigurationPresentation(configId: string): Q.Promise<ConfigurationPresentation[]>;

  /**
   * Get the presentation information for the given configuration ID.
   * The presentations can be inherited from parent configurations, and all those which are found
   * are returned - possibly none.
   * 
   * @return a (possiblt empty) list of ConfigurationPresentation.
   * 
   */
  getConfigurationPresentation(configId: string, callback?: (data: ConfigurationPresentation[])=>void): void;

  /**
   * Remove a previously-declared configuration presentation.
   */
  removeConfigurationPresentation(id: string): Q.Promise<void>;

  /**
   * Remove a previously-declared configuration presentation.
   */
  removeConfigurationPresentation(id: string, callback?: (data: void)=>void): void;

  /**
   * Get the currently registered option configuration for the provided id.
   * 
   * @throws OptionError if id is not known to the option manager
   */
  getOptionConfiguration(id: string): Q.Promise<OptionConfiguration>;

  /**
   * Get the currently registered option configuration for the provided id.
   * 
   * @throws OptionError if id is not known to the option manager
   */
  getOptionConfiguration(id: string, callback?: (data: OptionConfiguration)=>void): void;

  /**
   * Remove an option configuration
   * 
   * @param configId
   */
  removeOptionConfiguration(id: string): Q.Promise<void>;

  /**
   * Remove an option configuration
   * 
   * @param configId
   */
  removeOptionConfiguration(id: string, callback?: (data: void)=>void): void;

  /**
   * * Runs all registered configuration verifiers for the given configuration
   * * and all of its parent configurations. The hierarchy of configurations is
   * * traversed bottom-up and left-to-right.
   *    * <p>
   *    * Note that the configuration verifiers need to be registered directly
   *    * with the option handler implementation - adding verifiers from a client interface
   *    * is not supported as of now.
   * *
   * * @param config
   * * @return
   */
  verifyOptionConfiguration(config: OptionConfiguration): Q.Promise<VerifierError[]>;

  /**
   * * Runs all registered configuration verifiers for the given configuration
   * * and all of its parent configurations. The hierarchy of configurations is
   * * traversed bottom-up and left-to-right.
   *    * <p>
   *    * Note that the configuration verifiers need to be registered directly
   *    * with the option handler implementation - adding verifiers from a client interface
   *    * is not supported as of now.
   * *
   * * @param config
   * * @return
   */
  verifyOptionConfiguration(config: OptionConfiguration, callback?: (data: VerifierError[])=>void): void;

  /**
   * Get the build tool definition for the given id, or <code>null</code> if
   * none is registered
   * 
   * @param toolId
   *            unique id of the build tool, e.g. "iar.arm.compiler"
   * @return
   */
  getTool(id: string): Q.Promise<ToolDefinition>;

  /**
   * Get the build tool definition for the given id, or <code>null</code> if
   * none is registered
   * 
   * @param toolId
   *            unique id of the build tool, e.g. "iar.arm.compiler"
   * @return
   */
  getTool(id: string, callback?: (data: ToolDefinition)=>void): void;

  /**
   * Get a list of command line arguments for the specified tool
   * 
   * @param configId
   *            unique id of an option configuration to generate a command
   *            line for
   * @param toolId
   *            unique id of the build tool, e.g. "iar.arm.compiler"
   * @return a list of command line arguments for the tool, excluding the tool
   *         executable name
   */
  getToolCommandLine(configId: string, toolId: string): Q.Promise<string[]>;

  /**
   * Get a list of command line arguments for the specified tool
   * 
   * @param configId
   *            unique id of an option configuration to generate a command
   *            line for
   * @param toolId
   *            unique id of the build tool, e.g. "iar.arm.compiler"
   * @return a list of command line arguments for the tool, excluding the tool
   *         executable name
   */
  getToolCommandLine(configId: string, toolId: string, callback?: (data: string[])=>void): void;

  /**
   * Get the serialized value of an option (whether local or inherited) within an option
   * configuration or its ancestors.
   * 
   * @param configId
   * @param optionId
   * @return
   */
  getOptionValue(configId: string, optionId: string): Q.Promise<string>;

  /**
   * Get the serialized value of an option (whether local or inherited) within an option
   * configuration or its ancestors.
   * 
   * @param configId
   * @param optionId
   * @return
   */
  getOptionValue(configId: string, optionId: string, callback?: (data: string)=>void): void;

  /**
   * Get the value of a string option. Will throw if the option type is not
   * {@link OptionType#string}
   * 
   * @param configId
   *            Id of option configuration to derive the value from. The
   *            configuration ancestors or the option default value might be
   *            used to derive the value if it is not defined locally.
   * @param id
   *            unique id of the option
   * @return the option value
   */
  getOptionValueAsString(configId: string, id: string): Q.Promise<string>;

  /**
   * Get the value of a string option. Will throw if the option type is not
   * {@link OptionType#string}
   * 
   * @param configId
   *            Id of option configuration to derive the value from. The
   *            configuration ancestors or the option default value might be
   *            used to derive the value if it is not defined locally.
   * @param id
   *            unique id of the option
   * @return the option value
   */
  getOptionValueAsString(configId: string, id: string, callback?: (data: string)=>void): void;

  /**
   * Get the value of a string option. Will throw if the option type is not
   * {@link OptionType#Boolean}
   * 
   * @param configId
   *            Id of option configuration to derive the value from. The
   *            configuration ancestors or the option default value might be
   *            used to derive the value if it is not defined locally.
   * @param id
   *            unique id of the option
   * @return the option value
   */
  getOptionValueAsBoolean(configId: string, id: string): Q.Promise<boolean>;

  /**
   * Get the value of a string option. Will throw if the option type is not
   * {@link OptionType#Boolean}
   * 
   * @param configId
   *            Id of option configuration to derive the value from. The
   *            configuration ancestors or the option default value might be
   *            used to derive the value if it is not defined locally.
   * @param id
   *            unique id of the option
   * @return the option value
   */
  getOptionValueAsBoolean(configId: string, id: string, callback?: (data: boolean)=>void): void;

  /**
   * Get the value of a string option. Will throw if the option type is not
   * {@link OptionType#Enumerated}
   * 
   * @param configId
   *            Id of option configuration to derive the value from. The
   *            configuration ancestors or the option default value might be
   *            used to derive the value if it is not defined locally.
   * @param id
   *            unique id of the option
   * @return the enumerated value id of the option, see
   *         {@link IIarEnumeratedOptionValue}
   */
  getOptionValueAsEnumerated(configId: string, id: string): Q.Promise<string>;

  /**
   * Get the value of a string option. Will throw if the option type is not
   * {@link OptionType#Enumerated}
   * 
   * @param configId
   *            Id of option configuration to derive the value from. The
   *            configuration ancestors or the option default value might be
   *            used to derive the value if it is not defined locally.
   * @param id
   *            unique id of the option
   * @return the enumerated value id of the option, see
   *         {@link IIarEnumeratedOptionValue}
   */
  getOptionValueAsEnumerated(configId: string, id: string, callback?: (data: string)=>void): void;

  /**
   * Get the value of a string option. Will throw if the option type is not
   * {@link OptionType#StringList}, {@link OptionType#IncludePaths} or
   * {@link OptionType#PreprocessorSymbols}
   * 
   * @param configId
   *            Id of option configuration to derive the value from. The
   *            configuration ancestors or the option default value might be
   *            used to derive the value if it is not defined locally.
   * @param id
   *            unique id of the option
   * @return the option value
   */
  getOptionValueAsStringList(configId: string, id: string): Q.Promise<string[]>;

  /**
   * Get the value of a string option. Will throw if the option type is not
   * {@link OptionType#StringList}, {@link OptionType#IncludePaths} or
   * {@link OptionType#PreprocessorSymbols}
   * 
   * @param configId
   *            Id of option configuration to derive the value from. The
   *            configuration ancestors or the option default value might be
   *            used to derive the value if it is not defined locally.
   * @param id
   *            unique id of the option
   * @return the option value
   */
  getOptionValueAsStringList(configId: string, id: string, callback?: (data: string[])=>void): void;

  /**
   * Get the enumerated type definition for the given id
   * 
   * @param enumeratedTypeId
   * @return an {@link EnumeratedOptionType}, or <code>null</code> if
   *         undefined
   */
  getEnumeratedType(enumeratedTypeId: string): Q.Promise<EnumeratedOptionType>;

  /**
   * Get the enumerated type definition for the given id
   * 
   * @param enumeratedTypeId
   * @return an {@link EnumeratedOptionType}, or <code>null</code> if
   *         undefined
   */
  getEnumeratedType(enumeratedTypeId: string, callback?: (data: EnumeratedOptionType)=>void): void;

  /**
   * Evaluate a previously-registered condition on the provided configuration.
   * <p>
   * The condition is referred to by its id, and needs to be registered directly
   * with the option handler implementation - adding conditions from a client interface
   * is not supported as of now.
   * 
   * @param conditionId unique id of the condition to evaluate
   * @param configurationId unique id of the configuration on which to evaluate the condition
   */
  evaluateCondition(conditionId: string, configurationId: string): Q.Promise<boolean>;

  /**
   * Evaluate a previously-registered condition on the provided configuration.
   * <p>
   * The condition is referred to by its id, and needs to be registered directly
   * with the option handler implementation - adding conditions from a client interface
   * is not supported as of now.
   * 
   * @param conditionId unique id of the condition to evaluate
   * @param configurationId unique id of the configuration on which to evaluate the condition
   */
  evaluateCondition(conditionId: string, configurationId: string, callback?: (data: boolean)=>void): void;

  /**
   * Evaluate a previously-registered filter for an enumerated option in the provided configuration.
   * <p>
   * The filter is referred to by its id, and needs to be registered directly
   * with the option handler implementation - adding filters from a client interface
   * is not supported as of now.
   * 
   * @param filterId unique id of the filter to evaluate
   * @param configurationId unique id of the configuration on which the option to filter is present
   * @param optionId unique id of the enumerated option whose values should be filtered
   */
  evaluateEnumeratedOptionFilter(filterId: string, configurationId: string, optionId: string): Q.Promise<EnumeratedOptionValue[]>;

  /**
   * Evaluate a previously-registered filter for an enumerated option in the provided configuration.
   * <p>
   * The filter is referred to by its id, and needs to be registered directly
   * with the option handler implementation - adding filters from a client interface
   * is not supported as of now.
   * 
   * @param filterId unique id of the filter to evaluate
   * @param configurationId unique id of the configuration on which the option to filter is present
   * @param optionId unique id of the enumerated option whose values should be filtered
   */
  evaluateEnumeratedOptionFilter(filterId: string, configurationId: string, optionId: string, callback?: (data: EnumeratedOptionValue[])=>void): void;

  /**
   * Define an option
   * 
   * @param optionDefinition
   *                          desrciption of the option being registered
   */
  addOptionDefinition(optionDefinition: OptionDefinition): Q.Promise<void>;

  /**
   * Define an option
   * 
   * @param optionDefinition
   *                          desrciption of the option being registered
   */
  addOptionDefinition(optionDefinition: OptionDefinition, callback?: (data: void)=>void): void;

  /**
   * Unregister an option
   * 
   * @param optionId the unique id of the option to remove
   */
  removeOption(optionId: string): Q.Promise<void>;

  /**
   * Unregister an option
   * 
   * @param optionId the unique id of the option to remove
   */
  removeOption(optionId: string, callback?: (data: void)=>void): void;

  /**
   * Register a new build tool
   * 
   * 
   * @param tool
   *            description of the tool being registered
   */
  addTool(tool: ToolDefinition): Q.Promise<void>;

  /**
   * Register a new build tool
   * 
   * 
   * @param tool
   *            description of the tool being registered
   */
  addTool(tool: ToolDefinition, callback?: (data: void)=>void): void;

  /**
   * Unregister a build tool
   * 
   * @param id
   *            unique id of the tool, e.g. "iar.arm.tool.compiler"
   */
  removeTool(id: string): Q.Promise<void>;

  /**
   * Unregister a build tool
   * 
   * @param id
   *            unique id of the tool, e.g. "iar.arm.tool.compiler"
   */
  removeTool(id: string, callback?: (data: void)=>void): void;

  /**
   * Register an enumerated type
   * 
   * @param type
   */
  addEnumeratedType(type: EnumeratedOptionType): Q.Promise<void>;

  /**
   * Register an enumerated type
   * 
   * @param type
   */
  addEnumeratedType(type: EnumeratedOptionType, callback?: (data: void)=>void): void;

  /**
   * Unregister an enumerated type
   * 
   * @param typeId the type to remove
   */
  removeEnumeratedType(typeId: string): Q.Promise<void>;

  /**
   * Unregister an enumerated type
   * 
   * @param typeId the type to remove
   */
  removeEnumeratedType(typeId: string, callback?: (data: void)=>void): void;

  /**
   * Registers a new toolchain and its default configurations
   * 
   * @param toolchain
   */
  addToolchain(toolchain: Toolchain): Q.Promise<void>;

  /**
   * Registers a new toolchain and its default configurations
   * 
   * @param toolchain
   */
  addToolchain(toolchain: Toolchain, callback?: (data: void)=>void): void;

  /**
   * Unregisters a toolchain and its default configurations
   * 
   * @param toolchainId
   */
  removeToolchain(toolchainId: string): Q.Promise<void>;

  /**
   * Unregisters a toolchain and its default configurations
   * 
   * @param toolchainId
   */
  removeToolchain(toolchainId: string, callback?: (data: void)=>void): void;

  /**
   * Get a previously registered toolchain
   * 
   * @param toolchainId
   */
  getToolchain(toolchainId: string): Q.Promise<Toolchain>;

  /**
   * Get a previously registered toolchain
   * 
   * @param toolchainId
   */
  getToolchain(toolchainId: string, callback?: (data: Toolchain)=>void): void;

  /**
   * Get a list of all previously-registered toolchains
   * 
   */
  getToolchains(): Q.Promise<Toolchain[]>;

  /**
   * Get a list of all previously-registered toolchains
   * 
   */
  getToolchains(callback?: (data: Toolchain[])=>void): void;
}
